{"name":"Artificial Wars","tagline":"Retro robots programming game","body":"### Welcome to Artificial Wars.\r\n\r\nArtificial Wars is a game, where you get a bunch of robots and a task to complete. You are controlling your robots by writing programs which are controlling them. These programs are written in assembly dialect, which looks like this:\r\n\r\n```\r\nseta 32\r\nswp\r\nseta 50\r\nmove\r\n```\r\n\r\n### The robot\r\n\r\n* word of size 4 bytes (signed 32bit integer)\r\n* memory is word adressable\r\n* 1 general purpose register A of 1 word size \r\n* 1 store register B of 1 word size \r\n* 1 memory pointer register of 1 word size \r\n* 4 words of RAM\r\n* 64 words of ROM used to store program instruction codes\r\n* 64 words of ROM used to store instruction parameters\r\n* 1 lock register for storing positions of enemies\r\n* 5 hitpoints\r\n* 2 damage with each shot\r\n\r\nEach instruction has zero or one parameter, all parameters are signed 32bits integers. All\r\ninstructons are operating on signed arithmetics. There is no status register or\r\nstack. Jump instructions are using absolute adresses only.\r\n\r\nA is used for main arithmetics, as incrementation, decrementatin or storing result for\r\nadding and subtraction. B is used as additional storage for two operands operations,\r\nas addition or subtraction. Memory pointer is used to setting position to memory, where you can store values or load values from.\r\n\r\nEach instruction takes some cycles to execute. This time is multiplied if robot is moving.\r\n\r\n### Instructions\r\n\r\n```\r\n-\tno parameter\r\nP\tparameter\r\n\r\nName\tParam\tDescription\r\nwait\tP\twait for P*constant cycles.\r\nadd\t-\tadd B to A.\r\nsub\t-\tsubtract B from A.\r\ninc\t-\tincrement A by 1.\r\ndec\t-\tdectrement A by 1.\r\nswp\t-\tswap registers A and B.\r\nsetab\t-\tset value of B to A.\r\nseta\tP\tset parameter value to A.\r\nsetb\tP\tset parameter value to B.\r\nfire\t-\tfire a shot to location [A, B] (Can hit robot itself if used incorrectly).\r\nscan\t-\tsearch for enemy robots, if at least one exists, lock it.\r\nlock\t-\tset locked robot's X and Y coordinates to A and B.\r\nrnd\t-\tgenerate random integer from -parameter to parameter (included) and save it to A.\r\nrndb\t-\tgenerate random integer from -B to B (included) and save it to A.\r\nposx\t-\tsave current X position to A.\r\nposy\t-\tsave current Y position to A.\r\nmove\t-\tstart moving to location [A, B]. Instructions work while moving, but they are considerably slower.\r\nsetmp\t-\tset memory pointer to value of A. (Incorrect value of memory pointer may cause unexpected results)\r\nincmp\t-\tincrement memory pointer.\r\ndecmp\t-\tdecrement memory pointer.\r\nmemsave\t-\tsave value of A to memory using memory pointer.\r\nmemload\t-\tload memory value to A using memory pointer.\r\njmp\tP\tjump to different instruction line. (Incorrect value may cause unexpected results).\r\njmpz\tP\tjump to parameter instruction line if value in A = 0.\r\njmpc\tP\tjump to parameter instruction line if robot is collided with something and can not move.\r\njmpm\tP\tjump to parameter instruction line if robot is currently moving.\r\njmpl\tP\tjump to parameter instruction line if an enemy robot is locked. (lock != null)\r\n```\r\n\r\n### Assembly\r\n\r\neverything after ; is ignored until end of line\r\n```\r\nseta 5 ; this is comment\r\n; this is also comment\r\n```\r\n\r\nYou can use constants, variables, labels and macros. Available values are decimal, binary (starting with 0b), hexadecimal (starting with 0x) and octal (starting with 0).\r\n\r\nConstants are defined as:\r\n```\r\nname = value\r\n```\r\nThey can be used as parameters for instructions. They are replaced for values during compilation time.\r\n\r\nVariables are defined as:\r\n```\r\ntype name <value>\r\n```\r\nSupported type is int (4 bytes). Value is optional parameter. Value of memory can be changed during execution. Variables can be used as parameters for instructions. In that case, the address of variable is passed as instruction value.\r\n\r\nLabels looks like:\r\n```\r\nname:\r\n```\r\nThey mark address position in code, and can be used for quickly jumping from one position of code to another. Assembly supports only absolute jumps.\r\n\r\nMacros are chunks of code which can be inserted to assembly:\r\n```\r\nmacro name <parameters...>\r\n...code...\r\n/macro\r\n```\r\nEvery occurence of macro's name in assembly code is replaced with code defined in that macro. Macro can have parameters, which work similarly as constants.\r\n\r\n### Examples\r\nMoving robot and turning robot:\r\n```\r\nseta 100\r\nsetb 32\r\nmove\r\n```\r\nInfinite loop:\r\n```\r\ninf_loop:\r\njmp inf_loop\r\n```\r\nLoop of finding and firing after enemy:\r\n```\r\nlock_loop:\r\nscan\r\nlock\r\njmpl firing:\r\njmp lock\r\nfiring:\r\nfire\r\njmp lock\r\n```\r\nFor cycle:\r\n```\r\nseta 10\r\n; loop 10 times\r\nloop:\r\njmpz endloop\r\ndec\r\njmp loop\r\nendloop:\r\n; loop end\r\n```\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}